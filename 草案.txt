
〇Cardモデルの系統部分、ManyToManyfieldを使うのが良いと思う。
以下、chat先生。↓
https://chatgpt.com/c/6858d0a3-6560-800f-a3e2-acfc28696997

class ModelCards(models.Model):

class ModelRaces(models.Model):




〇fastAPI。select_sqlの返り値を簡単に。

# main.py
'''
起動コマンド
uvicorn main:app --reload --port 8080

テストコマンド
curl.exe -X POST http://localhost:8080/build/ -H "Content-Type: application/json" -d "@test.json"
'''


from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request, Depends
from connect import get_db, sql_select

app = FastAPI()


# getリクエストは本番じゃほぼ使わないがテスト用として。
@app.get("/")
async def get():
    return {'a':'aaa' , 'b':'bbb' , 'c':'ccc'}


# BuildSceneのリクエスト。
# Build場面はすべてpostで良いと思う。
# 検索条件(search_condition)を辞書型で受けて、connect.pyのselect関数に渡す。
@app.post("/build/")
async def post_build(request: Request , session = Depends(get_db)):
    search_condition = await request.json()
    print(search_condition)
    result = sql_select(session , **search_condition)
    print(result)
    if result is None:  # データがない場合
        return None
    
    else:  # 単一データ（.first() の戻り値）
        return result.dict__
    
    elif isinstance(result, list):  # 複数データあり
        return [user.dict_for user in result]


# RunSceneのリクエスト。
# Run場面はすべてwssが良いチャットっぽいので。
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Echo: {data}")
    except WebSocketDisconnect:
        print("Client disconnected")




# connect.py


from sqlalchemy import Column, String, Integer
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker, Session

# engineとSessionLocalとbaseのインスタンス化。
# FastAPI起動時の最初の1度だけ実行。以降、このインスタンスをずっと保持。
DATABASE_URL = "postgresql+psycopg2://work:pass0218@localhost/dbgame"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
base = declarative_base()


# sqlテーブルをモデルとして定義。
class User(base):
    __tablename__ = "app_byzer_game_card"
    id = Column(String, primary_key=True)
    name = Column(String)
    cost = Column(Integer)
    race = Column(String)
    effect_text = Column(String)

    def __repr__(self):
        return self.name
    


# FastAPIでの依存関数
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# SQLセレクト文を成形,実施する関数。
def sql_select(session, **conditions) -> list[User]:
    
    # クエリの宣言。
    query = session.query(User)

    # 引数として受けた検索条件がidを含んでいれば、idと合致するレコードを探索しreturn。
    if (id:= conditions.get('id')):
        query = query.filter(User.id == id)
        # 検索結果の取得。
        result = query.all() # 検索結果の件数に関わらずリスト型を返して欲しいので.all()とした。
        return result        # もし0件の場合は[]が返る。


    # 検索条件がidを含んでない場合、その他の検索条件で順番に絞り込み。

    if (ward := conditions.get('searchText')):
        query = query.filter(or_(
                             User.name.like(f"%{ward}%"),
                             User.race.like(f"%{ward}%"),
                             User.effect_text.like(f"%{ward}%"),
                             ))


    # query.all()やquery.first()で初めてRDBMSに問い合わせが入る。
    return query.order_by(User.cost).all()



〇草案

// Utility.cs でSeachByIDとSearchByConditionを作る。
// SeachByIDはビルドシーンでもランシーンでもよく使うのでUtility。
// でSearchByConditionもなんか役割似てるからUtilityで。
// 以下のコードはちょっと良くないかも。
// IEnumerator PostRequest：様々なシーンで利用するのでUtilityで定義。各シーンからStartCoroutine(Utiity.PostRequest())で各シーンから呼び出す、とかは？


class Utility
{

   
   public static IEnumerator PostRequest(string uri, 
                                         string jsonData, 
                                         Action<string> callback)
   {
        var request = new UnityWebRequest(uri, "POST");
        byte[] bodyRaw 
            = new System.Text.UTF8Encoding().GetBytes(jsonData);
        request.uploadHandler = new UploadHandlerRaw(bodyRaw);
        request.downloadHandler = new DownloadHandlerBuffer();
        request.SetRequestHeader("Content-Type", "application/json");

        yield return request.SendWebRequest();

        // もしも何かエラーがあれば
        if (request.result == UnityWebRequest.Result.ConnectionError ||
            request.result == UnityWebRequest.Result.ProtocolError)
        {
            Debug.LogError(request.error);
        }
        // もしもエラーが無ければ
        else
        {
            // 呼び出したコルーチンにjson形式の文字列を返す。
            callback?.Invoke(request.downloadHandler.text);
        }


   } 
}


class BuildManager:MonoBehavior
{

   // idを受けて、合致したレコードをjson文字列として返す。
   // 返り値jsonをどうやってデシリアライズするかは呼び出し毎に定義。
   public string SeachByID(string id)
   {
	string result = Null;

        // postリクエストをコルーチンで呼び出し。
        StartCoroutine(Utility.PostRequest(url , jsonData , (response) =>
	{
            Debug.Log($"Received message: {response}");
	    result = response;
        }));
	
	
   }

   // SearchConditionを受けて、合致したレコードをjson文字列として返す。
   //public string SeachByCondition(SearchCondition condition)
   //{
   //}


}



// クラス定義
class SearchCondition
{
   // public string id; 
   // →idは不要で。id検索するときは他の検索条件は要らない。
   public string name ;
   public int? age ; // nullを許容するint型。
   public string memo;

// インスタンス化のときはこう。
//var condition = new SearchCondition
//{
//    name = "Taro",
//    age = null, // null OK
//    memo = "test memo"
//};

}



