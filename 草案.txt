C#側でSearchConditionをシリアライズするときのコード案。


using Newtonsoft.Json;

// クラス定義
class SearchCondition
{
   public string id;
   public string name ;
   public int? age ;
   public string memo;
}


// インスタンス化
var condition = new SearchCondition
{
    id = "123",
    name = "Taro",
    age = null, // ここは null OK
    memo = "test memo"
};

//fastapi。

# main.py
'''
起動コマンド
uvicorn main:app --reload --port 8080

テストコマンド
curl.exe -X POST http://localhost:8080/build/ -H "Content-Type: application/json" -d "@test.json"
'''


from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request, Depends
from connect import get_db, sql_select

app = FastAPI()


# getリクエストは本番じゃほぼ使わないがテスト用として。
@app.get("/")
async def get():
    return {'a':'aaa' , 'b':'bbb' , 'c':'ccc'}


# BuildSceneのリクエスト。
# Build場面はすべてpostで良いと思う。
# 検索条件(search_condition)を辞書型で受けて、connect.pyのselect関数に渡す。
@app.post("/build/")
async def post_build(request: Request , session = Depends(get_db)):
    search_condition = await request.json()
    print(search_condition)
    result = sql_select(session , **search_condition)
    print(result)
    if result is None:  # データがない場合
        return None
    
    else:  # 単一データ（.first() の戻り値）
        return result.dict__
    
    elif isinstance(result, list):  # 複数データあり
        return [user.dict_for user in result]


# RunSceneのリクエスト。
# Run場面はすべてwssが良いチャットっぽいので。
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Echo: {data}")
    except WebSocketDisconnect:
        print("Client disconnected")




# connect.py


from sqlalchemy import Column, String, Integer
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker, Session

# engineとSessionLocalとbaseのインスタンス化。
# FastAPI起動時の最初の1度だけ実行。以降、このインスタンスをずっと保持。
DATABASE_URL = "postgresql+psycopg2://work:pass0218@localhost/dbgame"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
base = declarative_base()


# sqlテーブルをモデルとして定義。
class User(base):
    __tablename__ = "app_byzer_game_card"
    id = Column(String, primary_key=True)
    name = Column(String)
    cost = Column(Integer)
    race = Column(String)
    effect_text = Column(String)

    def __repr__(self):
        return self.name
    


# FastAPIでの依存関数
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# SQLセレクト文を成形,実施する関数。
def sql_select(session, **conditions) -> list[User]:
    
    # クエリの宣言。
    query = session.query(User)

    # 引数として受けた検索条件がidを含んでいれば、idと合致するレコードを探索しreturn。
    if (id:= conditions.get('id')):
        query = query.filter(User.id == id)
        # 検索結果の取得。
        result = query.all() # 検索結果の件数に関わらずリスト型を返して欲しいので.all()とした。
        return result        # もし0件の場合は[]が返る。


    # 検索条件がidを含んでない場合、その他の検索条件で順番に絞り込み。

    if (ward := conditions.get('searchText')):
        query = query.filter(or_(
                             User.name.like(f"%{ward}%"),
                             User.race.like(f"%{ward}%"),
                             User.effect_text.like(f"%{ward}%"),
                             ))


    # query.all()やquery.first()で初めてRDBMSに問い合わせが入る。
    return query.order_by(User.cost).all()


